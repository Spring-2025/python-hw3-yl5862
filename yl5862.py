# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MfBEM0iErfo4Q3hhX_A3JfTCjSlEXk-B
"""

import yfinance as yf
import pandas as pd

def get_stock_data(symbol):
    """
    Downloads stock data from Yahoo Finance and returns adjusted closing prices if available.
    Falls back to 'Close' prices if 'Adj Close' is missing.
    """
    data = yf.download(symbol, progress=False)

    print("Available columns:", data.columns)

    if 'Adj Close' in data.columns:
        return data['Adj Close']
    elif 'Close' in data.columns:
        return data['Close']
    else:
        raise ValueError("Neither 'Adj Close' nor 'Close' found in the data.")

def calculate_returns(price_series):
    """
    Computes daily percentage returns from a pandas Series of prices.
    """
    returns = price_series.pct_change().dropna()
    return returns

if __name__ == "__main__":
    symbol = "GS"
    try:
        prices = get_stock_data(symbol)
        print("\nStock Prices (Last 5 rows):\n", prices.tail())

        returns = calculate_returns(prices)
        print("\nStock Returns (Last 5 rows):\n", returns.tail())

    except Exception as e:
        print("Error fetching data:", e)

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

def VaR(r, confidence, principal=1):
    """
    This function calculates the Value at Risk (VaR) at a given confidence level.

    Parameters:
    - r: array-like, stock return series
    - confidence: float, confidence level (e.g., 0.95 for 95% confidence)
    - principal: float, initial investment value (default is 1)

    Returns:
    - VaR: Estimated potential loss at the given confidence level
    """
    alpha = 1 - confidence
    var_percentile = np.percentile(r, alpha * 100)
    VaR_value = principal * abs(var_percentile)
    return VaR_value

def percent_var(r, confidence):
    """
    Computes the percentile-based VaR and plots the return distribution histogram.

    Parameters:
    - r: array-like, stock return series
    - confidence: float, confidence level (e.g., 0.95 for 95% confidence)

    Returns:
    - Percentile-based VaR
    """
    alpha = 1 - confidence

    plt.hist(r, bins=50, alpha=0.75, color='blue', edgecolor='black')
    plt.title(f"Return Distribution - {confidence*100}% Confidence Level")
    plt.xlabel("Returns")
    plt.ylabel("Frequency")
    plt.axvline(np.percentile(r, alpha * 100), color='red', linestyle='dashed', linewidth=2, label="VaR Threshold")
    plt.legend()
    plt.show()

    var_value = np.percentile(r, alpha * 100)
    return abs(var_value)

if __name__ == "__main__":
    returns = np.random.normal(0, 1, 10000)
    print(f"97.72% percentile: {np.percentile(returns, 97.72)}")

    r = np.random.normal(0.05, 0.03, 1000000)
    probability2SD = norm.cdf(2)
    my_confidence = probability2SD
    my_percent_var = percent_var(r, my_confidence)
    print("Computed Percentile-based VaR:", np.round(my_percent_var, 2))
    print("VaR test passed:", np.round(my_percent_var, 2) == 0.01)

    investment_value = 1000000
    my_VaR = VaR(r, my_confidence, investment_value)
    print(f"Estimated VaR at {my_confidence*100:.2f}% confidence: ${my_VaR:,.2f}")

import numpy as np

def ES(losses, confidence=None, VaR=None):
    """
    Calculate the Expected Shortfall (Conditional VaR) of losses.

    Parameters:
    - losses: array-like, positively stated loss values.
    - confidence: float, confidence level (e.g., 0.99 for 99%).
    - VaR: float, optional dollar value specifying the Value at Risk (VaR) threshold.

    Returns:
    - Expected Shortfall (ES): The average loss exceeding the VaR threshold.
    """
    if VaR is None:
        if confidence is None:
            raise ValueError("Either confidence level or VaR must be provided.")
        VaR = np.percentile(losses, 100 * (1 - confidence))
    exceeding_losses = losses[losses > VaR]
    if exceeding_losses.size == 0:
        return VaR
    es_value = np.mean(exceeding_losses)
    return es_value

if __name__ == "__main__":
    losses = np.random.uniform(0, 100, 100000)
    es_confidence = ES(losses=losses, confidence=0.8)
    print(f'ES with confidence 80%: {np.round(es_confidence, 0)}')

    es_var = ES(losses=losses, VaR=80)
    print(f'ES with VaR = 80: {np.round(es_var, 0)}')

    print("ES confidence test passed:", np.round(es_confidence, 0) == 90)
    print("ES VaR test passed:", np.round(es_var, 0) == 90)